---
title: "破碎的瓦片是如何保障您的隐私安全的"
date: 2023-08-07T12:16:33+08:00
draft: false
categories: Computer Science
---

读者朋友们肯定没少听说过一项技术，“GnuPG”，or GNU Privacy Guard. 这是一种加密与签名技术，通过数学算法和随机性来保障数据传输隐私可信任。它的特点是：0密钥交换。譬如，当A向B请求一份文件时，B只需要知道A的公钥，并根据公钥加密，而A可以在本地，安全地使用不用发送给任何人的私钥来解密。如果A向B请求一份不需要加密，但需要知道是不是B本人负责的文件，则B用自己的密钥来计算一份签名，A使用公钥核实签名是否符合公钥：由于密钥不应发送给任何人，就意味着只有B有他的密钥，他就可以使用这份密钥声明一份内容是他所撰，或至少过了他的眼。有关这一过程具体如何操作，可以查看我之前写的[《走向隐私——GnuPG简单教程》](/cs/走向隐私——GnuPG简单教程.md)

本文则不是一篇教程。相反，本文从一个遥远的故事讲起，阐述GPG是如何通过随机性和数学原理来实现短期内牢不可破的加密的。

相传在很久以前，有一个人到集市上去买头牛。牛的价格很贵，而且体型也很大，实在不方便带很多头到集市上来现买现卖。于是，当他看中了一户准备交易时，商家收下钱后便从地上拾起一块瓦，用桌檐把它碎成两块。一块递给了买家，一块卖家自己保留。卖家说，明天你可以到我家来取牛，只需要把你的那块和我的这块拼一下，如果能严丝合缝地拼在一起，便证实了身份，我也就知道要给你牛了。

这个故事，成了古代人民智慧的典范。同时这个故事，和现代常用的加密手段，也恍惚之间有异曲同工之妙。在故事里，买家拾起一块瓦片，并把它碎成两半的过程，瓦的裂痕便是破碎所产生的不可预测的“真随机”。而这一情景，不觉得让人眼熟吗？在一些系统中，生成密钥时，便会要求用户“随意移动鼠标”来制造真随机数，也是和碎瓦一个道理。而现代密钥对加密系统的关键，正是这个随机。

在GPG使用的RSA/DSA算法中，防止破解的关键在于两个大素数，同碎瓦的裂痕很难被模仿一样，超大的素数非常难以分解，所以保障安全。而同样，碎瓦的裂痕难以被模仿，正是依赖着瓦破碎时的裂纹是一套极其复杂、混沌（依赖于温度、湿度、力度等等）机制所产生的结果；而RSA密钥对的生成，也当然就需要使用者，或者计算机的某些安全性能芯片，提供一套足够混乱，无法预测的“真随机”机制。

获取到随机数后，RSA算法会将选择的两个随机大素数相乘，这两个素数之积n (n = p * q) 构成了加密过程中的模数。大素数分解，即n分解成p和q之积，在当前的计算能力下是非常耗时的，由此，RSA加密算法才更安全。当解密时，RSA会使用“欧拉函数”，记为φ(n)，指小于n的正整数中与n互质的数的个数。有φ(n) = (p-1)(q-1)，其中p和q是两个选定的素数。欧拉函数的一个重要性质是如果a和n互质，那么a的φ(n)次幂模n等于1，即 a^φ(n) ≡ 1 (mod n)。此属性在RSA算法中被应用于解密过程。此时，买牛者拿走了瓦片，并保留备用。

那所谓密钥对，当然有两个密钥，一个是随意发布的公钥，一个是绝对保密的私钥。设公钥指数e，私钥指数为d，加密时，使用公钥参与模幂运算，对于明文m，有c = m^e (mod n)；用私钥解密时，有明文 m = c^d (mod n)。这时就像买牛者和卖牛者拼合了瓦片，确认了身份。

以GPG作为代表的一批RSA、DCA原理的加密算法，或有形，或无形地保护着我们的数据安全。而有时，当回望历史，可以看见颇有趣味的倒影。

*自本文发表起，本站点正式使用经过GPG签名的Git Commit.*