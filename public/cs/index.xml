<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cs on 荷岭网居</title>
    <link>/cs/</link>
    <description>Recent content in Cs on 荷岭网居</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 22 Jun 2023 12:17:02 +0800</lastBuildDate><atom:link href="/cs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SLP协议的GO语言实现推荐，附HTTP接口一则</title>
      <link>/cs/slp-mc-go-implement/</link>
      <pubDate>Thu, 22 Jun 2023 12:17:02 +0800</pubDate>
      
      <guid>/cs/slp-mc-go-implement/</guid>
      <description>Minecraft是世界上最受欢迎的游戏之一。它的联机功能（服务器）也应用极为广泛。对于喜欢联机游戏的用户而言，可以显示服务器状态和简介的“服务器列表”功能十分实用。而用户向服务器列表中添加了服务器的IP和端口，Minecraft获取有关此服务器元数据的详细过程，则很有探讨的价值。通过一系列调查，爱好者们已经明确，Minecraft客户端会使用自研的一套应用层协议，与远端的机器进行元数据交换。这套协议就是SLP协议，SLP代表Server List Ping （服务器列表Ping）
在wiki.vg上，SLP的具体原理已经被详细记录。以1.7+版本的SLP为例，端侧会首先向云侧发起Handshake（握手）请求，即发送HandShake包。这个第一个包使用的是为大家所熟悉的常规Client-Server协议，内容大致如下：
Packet ID Field Name Field Type 0x00 Protocol Version Int Server Address String Server Port Unsigned Short Next state Int 这些信息需要发送给服务端。此外还要处理接下来的一系列回包。总之，如果我们要在编程语言中处理这些信息，使用“纯手动”的模式的话，还是有些困难的。
所幸，在GO语言中的一些包可以帮助我们方便地发送一系列数据包，用一种相对“自动档”的模式。其中我推荐的是MineQuery，主要因为它流畅的调用体验，以及对于高版本GO语言的兼容性。要安装它，你可以在适当的位置运行
go get -u &amp;#34;github.com/dreamscached/minequery/v2&amp;#34; 然后，你可以打开需要编程的.go文件，通过 minequery.Ping*()函数 (*代表协议使用的版本)来自由地获取Minecraft服务器的数据。有关更多用法，你可以访问该项目的Github Repo.
我的例子 这里提供使用例一则，把这个函数绑定到某个HTTP服务，作为其回调接口，请求这个接口就可以获得Ping包返回的JSON信息（原封不动）
func MinecraftServerInfoHandler(w http.ResponseWriter, r *http.Request) { hostname := r.URL.Query().Get(&amp;#34;ip&amp;#34;) port, err := strconv.Atoi(r.URL.Query().Get(&amp;#34;port&amp;#34;)) if err != nil { w.WriteHeader(http.StatusInternalServerError) errMessage := McServerQueryError{Err: err, Msg: &amp;#34;Invalid Port Number&amp;#34;} msg, _ := json.Marshal(errMessage) w.Write(msg) return } res, err := minequery.</description>
    </item>
    
    <item>
      <title>加上这个Meta属性，保护隐私！</title>
      <link>/cs/add-this-to-protect-privacy/</link>
      <pubDate>Sun, 04 Jun 2023 21:16:50 +0000</pubDate>
      
      <guid>/cs/add-this-to-protect-privacy/</guid>
      <description>日常生产生活中，很多人看HTTP标头的时候都会发现一个这样的字段：
Referer: https://example.com/example 这个Referer字段是什么意思呢？其实这是一个HTTP协议设计的“历史遗留问题”。因为当时开发的程序员可能是熬夜了，眼睛昏花，敲错了字，把原来的Referrer，也就是“来源”，敲成了Referer。后来有关方面曾经尝试过修复，并推出了新的标头，毕竟HTTP协议这种东西作为现代互联网基石最好严谨些。但无奈这个标头已经广泛推送给了大多数客户端和服务端，所以修改进程遇到很大的阻力，最后宣布失败，新标头被弃用并移除。
Refer(r)er 的危害 懂英语的人可能看懂了本文封面的那行代码：即禁用浏览器向HTML引用的资源服务器发送Referrer. 这种情况下就可以实现隐私保护。
现在假设有一个A网站，没有设置这行代码，而A网站中嵌入来自B网站的某个css文件。浏览器照常工作，把标头发送给B网站的服务器。但出乎所有人意料的是，B网站是一个对隐私极其不友好的网站，它把所有请求Referrer全部记录下来。因为B网站上的所有页面都引用了这个CSS。所以可以说，B网站现在有方法可以统计A网站的访客数量，以及专门针对A网站的访客进行进一步的隐私冒犯，这是非常危险的。（在这种情况下，对于B网站而言，用户们从“互联网用户”分为“A网站的用户”和“其他网站的用户”，而后者还可以进一步划分成D网站、E网站的用户等等，这种行径往往是进一步隐私冒犯的前兆）
而且，不只是外联引入中发送Referrer这种隐蔽形式，连超链接也会发送，用户点击超链接的时候可能没有想到，因为所有人都觉得这种手段也太明目张胆了。但是请看：现在A网站上有一个链接指向了B网站的某个页面，当用户点击A网站的链接跳转到B网站时，B网站竟然能获知这个用户是从哪里来的。其实这就是网络追踪，而且还是最低劣的手段，且一般不会被常见的追踪拦截器拦截，就取得了用户具体的网络浏览路径。无疑是大大降低了跟踪成本。
采取措施 Referrer用处很大，最出名的当属防盗链。所以不可能指望废除Referrer字段。但在现代浏览器中，（当然不包括IE）都可以通过一句话的HTML来实现禁止浏览器向外部资源发送该字段。根据Can I use的报告，看起来就是IE也支持设定为origin，虽然这个模式对隐私保护的作用不大。
根据MDN的文档，通过Referrer Policy实现了对是否发送Referrer字段的控制。具体需要通过一句HTML代码，在&amp;lt;head&amp;gt;中实现
&amp;lt;meta name=&amp;#34;referrer&amp;#34; content=&amp;#34;${The Policy}&amp;#34; /&amp;gt; 目前一共支持包括不发送任何Referer字段的no-referrer和只发送主机名的origin在内的共八种政策。但前者是对隐私保护最有利的，因为其他类型都会或多或少，或具体或模糊地对外发送Referer.
但在采取措施时还需格外注意，将Referer字段置空意味着无法再通过设置白名单为仅包含自己的域名来防盗链，否则自己的网站上也无法显示自己的资源。所以还需谨慎设置。</description>
    </item>
    
    <item>
      <title>对AI绘画原理的小澄清</title>
      <link>/cs/%E5%AF%B9ai%E7%BB%98%E7%94%BB%E5%8E%9F%E7%90%86%E7%9A%84%E5%B0%8F%E6%BE%84%E6%B8%85/</link>
      <pubDate>Sun, 30 Apr 2023 15:07:00 +0000</pubDate>
      
      <guid>/cs/%E5%AF%B9ai%E7%BB%98%E7%94%BB%E5%8E%9F%E7%90%86%E7%9A%84%E5%B0%8F%E6%BE%84%E6%B8%85/</guid>
      <description>本文包含了ChatGPT（GPT3.5-Turbo）生成的内容，但并非全部照搬。
人工智能技术在发展，AI绘画这一领域也受到社会各界关注。其中的AI绘画，自2022年底开始，作为一项富有争议的新兴技术，就触动了不少人的神经。然而，许多针对AI绘画发表自己见解的人，在对AI绘画原理的误解上就产生了很多偏差。其中最为常见的一个，是认为AI绘画只是简单地把画师的作品拼合而成，最多在接缝处用所谓的技术平滑处理一下，没有任何独创性和创造力。这种想法，既是对严谨的科研精神的背叛，也是对实事求是的艺术精神的羞辱，无论对于AI绘画还是对于传统艺术的研究和发展都不利，因此，具体说说以Stable Diffusion为首的一批AI绘画的原理，还是十分必要的。还要补充的是，Stable Diffusion虽作为AI绘画中最先引起轰动的那个，却并不是现代CS界最先进的绘画程序，尤其在非人物方面，Midjourney可能更胜一筹。
Stable Diffusion 官方仓库 NovelAI 官方网站 Midjourney 官方网站
首先，我们需要承认，固有的思维方式，无疑会引导我们对于AI绘画的产生不同的立场、认知。对于习惯了传统思想的人而言，认为AI绘画只是简单地将画师的作品拼合起来是非常自然的想法。因为他们的思路已经固定，在看到大量的标准化、批量复制传统艺术或商业化艺术的美学后，将AI绘画自然地当作传统艺术的延续，因此难以从根本上理解AI绘画的形式与意义。这种固有的观念禁锢，让他们局限在传统的艺术框架内，很难看到AI绘画的全新解构和超越。而拼图的这一种观点，就是旧观念和一种半瓶水的学习态度所共同造成的恶果，或者是别有用心之人面向公众散播恐慌的方式。许多画师轻易地相信AI绘画是拼图，也是因为拼图作为一种经典的抄袭手段，正好和AI的版权争议这一不争的事实相吻合。
然而，我们也不能否认，AI绘画确实存在一些缺陷。对于绘制某些特定对象方面，AI绘画依然存在一些局限性，不如人类艺术家灵活多变，难以自然地表达出情感和情感细微的表情，难以刻画具体事物，如画手、画面条。同样，AI绘画的创造也不是完全独立的，它们需要提取先前的画作来进行学习和模仿，因此存在着一定的“套路化”和“创意受限”，且因为训练集里的内容侵犯版权甚至人权，这些作品还要面临复杂的舆论风暴和法律争议。但是，这并不能够说明AI绘画只是单纯的拼接，或者如某些人所想，是所谓的“炼丹”工艺。恰恰相反，这更加体现出，AI是难以妄下定论的复杂工业品，它们可以通过加强自学习及深度学习的算法，无限接近于人类的思维和表达，在发展中更加自然地表达出“情感”与“意境”——因为若只是简单的拼图，那对于那些手、面条等元素，又怎么会变得模糊不清呢？难道是“原图”本来就很模糊而一笔带过吗？想想，大抵是不会的。面对不曾了解过的技术，与其胡诌一通，揣测它的内部原理，还不如把它当成简单的“黑箱子”，这样都比胡编乱造来得实在一些。
逻辑的论证是空虚的，然而，真的落到实处来看，Stable Diffusion的官方仓库中已经阐释了其内部具体的工作原理。只是涉及了很多专业术语，而“拼图”则是一个错误的过度简化。Stable Diffusion的本质，在生成的时候其实是一种降噪算法。可以理解为是让不清楚的图片变得清楚的一项“黑科技”。一个形象的比方是，到了冬天，窗户上凝结了许多水汽，窗外的世界都变得模糊了。而这就是Stable Diffusion生成一张图片时第一步所做的——它通过NLP（自然语言处理）分析用户的提示词，并根据这一讯息生成模糊至极的色块，就好像玻璃上厚重的雾。但通过对噪声图像进行多轮迭代，也就是拿一张纸去擦玻璃，逐渐就能生成分辨率高、真实感强的图像。这个纸就是一切AI中经常出现的一项技术，“梯度下降算法”，以它的力量来擦掉名为“图片噪音”的雾。在数学上，用初中的知识来解释，就是去找一个开口向上的函数图像的顶点，譬如是一个二次函数，那它的定点横座标就是-b/2a,原理都是相似的。只是计算机所处理的这个函数，不像初中学的那些函数，只有一个参数。相反，它可以有几亿个参数。凭借着CPU或GPU的强劲算力，计算机得以将一个特定的损失函数最小化，也就是一步步逼近某个n次n维函数的最低点，从而生成出与特定输入条件相匹配的图像。
Diffusion的英文原意是“扩散”，这就是这个AI的本职工作。（Stable则是自卖自夸，形容稳定。）这个过程中涉及图像具体处理的部分，首先是需要准备一个噪声图像。该图像包含了一些随机噪声的元素，并且极不清晰；而这个图像的生成，就是根据NLP对用户提示词的处理结果和一些随机数而从训练集里选择的。其实和人类绘画的过程并无大差，只是迭代的次数要多得多了——人类绘画是要打草稿的，这个噪声图像就是AI的草稿，AI就像人一样在这个时候便会确定什么地方该有什么，它该是什么颜色的。然后，利用一个深度神经网络（这个网络的形成当然也是依靠大量的图像训练，对其中的权重、参数进行调整）对其进行迭代，每一轮迭代都会对噪声图像进行“扩散”，即将它转化为一个更加细致、复杂的图像。所以擦窗户的纸或者布也正是用那些图片揉合起来造的。在每一轮迭代后，也会通过数学函数来评估生成的图像的质量，并根据反馈调整进行下一轮迭代。
由此看来，Stable Diffusion的原理也没有那么邪恶，至少不是明目张胆的狂抄。但这也并不是说用Stable Diffusion所制作的作品可以声称完全的版权，并接受来自法律的完全保护。这个问题实际上应该深发到更高的层面上，是关于版权本身的拷问。因为SD的原理是否可以看作和人类相同的一种学习行为，所以产生的作品可以主张完全版权，还是应该看作一种技术实验，一种产品，注定只能被放到公共领域里，作为CS爱好者的小众爱好，且严禁商业使用？
但无论如何，我们也不能忽视AI绘画的实际价值，不能对AI绘画简单的选边站。通过AI绘画，我们可以大大提高数字制图和算法绘制的效率，加快科技进步的步伐；通过AI绘画，小创作者可以越过知识和资金的限制，为自己的作品提供更好的创意，可以筹得一些捐款（不是直接用AI绘画盈利），获得选择人类画师来更好合作的自由，推动艺术的发展到一个全新的阶段。同时，AI绘画也将赋能技术，给CS带来新的机遇，有利于完善计算机这一伟大的互联网工具。
综上所述，我们在理解和认识AI绘画的时候，要有辩证的思考方式并比较分析。我们不能只看到其局限性，也不能过分夸大其优势和实际价值。许多CS工作者已经发现，2022到2023年的这些爆炸式增长的AI，在原理上其实没有什么创新。它们只不过是运用了更大、更大的训练集，仅此而已。无论有多大的阻碍，AI也会不断进化发展，技术的迭代也势必对艺术产生诸多影响。同时，也应该尊重传统的艺术创作者，艺术不是工业，而是人类对美好事物追求和一种社会手段。推进人工智能和文化艺术的共同发展，才是今后最有可能的主流声音。
临考日记计划SHSEE Diary Project雁过留声，人过留文。离中考还有49天，我希望能够通过写日记的方法，坚持到中考前一周左右，记录所见所闻所感。这是本计划中的第2篇文章。感谢您的支持！
中心化博客 个人首页 博客导航</description>
    </item>
    
    <item>
      <title>如何优化网站的加载速度</title>
      <link>/cs/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</link>
      <pubDate>Tue, 28 Mar 2023 20:58:54 +0000</pubDate>
      
      <guid>/cs/%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E7%BD%91%E7%AB%99%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6/</guid>
      <description>(AI Content, Provided by ChatGPT)
随着互联网的快速发展，网站已成为人们获取信息和进行交流的重要渠道。然而，随着网站内容的增加和用户访问量的增加，网站的加载速度也成为了一个很大的问题。过慢的加载速度会导致用户体验不佳，甚至会让用户放弃访问网站。因此，优化网站的加载速度成为了每个网站管理员必须要关注的问题。
那么，如何优化网站的加载速度呢？下面我将为大家介绍一些常用的优化方法。
压缩文件 网站中的文件包括CSS、JavaScript和HTML等，这些文件越大，加载速度就越慢。因此，我们可以使用压缩工具来减小文件的大小，从而提高网站的加载速度。常用的压缩工具有Gzip和Brotli等。
使用CDN CDN即内容分发网络，它可以将网站的静态资源缓存在全球各地的服务器上，从而在用户访问网站时可以更快地获取资源，提高网站的加载速度。
优化图片 图片在网站中占据了很大的比重，因此优化图片也是提高网站加载速度的一个关键点。我们可以通过压缩图片、使用适当的格式、减少图片数量等方法来优化图片。
使用缓存 缓存可以将网站的静态资源缓存在用户的浏览器中，从而在用户再次访问网站时可以更快地获取资源，提高网站的加载速度。
减少HTTP请求 HTTP请求是网站加载速度慢的一个主要原因，因此我们可以通过减少HTTP请求的方式来提高网站的加载速度。具体方法包括合并文件、减少页面元素等。
总之，优化网站的加载速度是一个持续的过程，需要不断地进行调整和优化。通过上述方法，我们可以提高网站的加载速度，从而提高用户体验，吸引更多的用户访问网站。</description>
    </item>
    
    <item>
      <title>走向隐私——GnuPG简单教程</title>
      <link>/cs/%E8%B5%B0%E5%90%91%E9%9A%90%E7%A7%81gnupg%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 05 Mar 2023 11:34:00 +0000</pubDate>
      
      <guid>/cs/%E8%B5%B0%E5%90%91%E9%9A%90%E7%A7%81gnupg%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</guid>
      <description>GNU Privacy Guard（GnuPG 或 GPG）是一个密码学软件，用于加密、签名通信内容及管理非对称密码学的密钥。GnuPG 是自由软件，遵循 IETF 订定的 OpenPGP 技术标准设计，并与 PGP 保持兼容。
&amp;ndash;Wikipedia
工作原理 说到加密，我们往往会想起的是给文档或者压缩包设置一个读取密码。这种加密确实是一种廉价又不失安全性的加密方案。加密后的文件可以通过互联网传输，而读取文件的密码则可以通过其他较为安全的方式传递。在计算机科学中，把以密码为基础的加密称为“对称式加密”，即用什么加密的就用什么解密。
然而，这种加密方式也存在很大的问题。一个比较轻的问题是，利用这种途径加密的文件，其密码可以通过电脑暴力尝试来破解。只要有足够的利益驱使，且密码比较简单，可以在几天之内完成破译。一个最为严重的问题是，通过密码来加密的文件，其密码也需要传递。而如果有什么希望破译文件的第三方能获取到密码，就一定能打开文件。此外还有：如果文件被中途破译并修改再重新加密，密码加密也无法显示文件是否被篡改；如果文件被错误地发送或者发送者想要撤回，则基本上没有可行的方式。
这个时候，几位来自美国的程序员开发了PGP加密技术。这项加密技术旨在实现零密钥交换的通用信息加密——“非对称加密”。
所谓的非对称加密，可以理解为，不再用同一个密码进行加密和解密两套操作。而是用第一串密码（公钥）加密，再用和它有配对关系的第二串密码（私钥）解密。这当中涉及一些复杂的密码学原理，但总之，可以理解为通过一些数学方法，计算机科学家实现了能够产生“一对”密码（密钥对）的方法来实现上述功能。
这样一来，信息的加密就迎来了颠覆。小明想要小红发送一份文件给自己，那么，小明就把自己的公钥发送给小红。小红拿到了公钥，在自己的设备上用小明的公钥加密一份文件。此时，加密出来的文件只能用小明自己的私钥才能解密，如果加密时没有设置，别说什么第三方了，就是小红自己也无法解密。在整个信息传递过程中，让我们回忆一下在互联网上过去了什么信息：一份来自小明的小明的公钥、一份来自小红的已经经过加密的文件。而至关重要的，能够解密文件的那个私钥则始终安然躺在小明的电脑里，从未在网上传递。在第三方视角，那份加密文件就是不可解密的。
可以说，上述过程是所有非对称加密的基本原理，实际会有一些偏差。譬如使用私钥加密而公钥解密的情况也大有出现，而且为了避免诸如“公钥欺诈”的破译手段还要做一些额外的信息交换等等。并且，在任何一个真正的非对称加密应用程序中，“既然追求保密，那就贯彻到底”，为了防止可能的暴力破解，密钥对里的公钥和私钥都是一个巨长的字符串，暴力破解的时间要到20年往上了。
此外，非对称加密还有一些别的好处。还是小明和小红，小红可以选择在给小明加密文件的同时用自己的私钥给文件附上一份签名，使得文件内容一旦修改，小明的客户端就能提示。如果小明收到文件后意外地把私钥泄漏到了公开互联网上，他还可以使用吊销证书来吊销密钥对，此时所有的用小明公钥加密的文件将永远无法通过任何方式来解开了。
不过，简单的非对称加密也不是万无一失的。之前提到了“公钥欺诈”，就得说说非对称加密的弱点。小明给小红发送了自己的公钥，这个公钥最终还是要从网络上走的。如果网络流量本身没有被加密和防篡改，那第三方可以将小明的公钥篡改为那个第三方的公钥，不明真相的小红拿到公钥后用它给那个所谓的小明，实际上是第三方加密了文件，然后再通过网络回传给小明。此时那个第三方再次截获那个已经加密的文件，用自己的私钥就可以解密了。通过“公钥欺诈”，第三方成功破译了加密文件。
但是，对于进阶的非对称加密使用者，第三方的这种把戏终究是愚蠢的。因为在这个时候，小明也收到了小红发的那个加密的文件，并开始用自己的私钥来解密——结果是无法解密——当然无法解密了，因为它根本不是用小明密钥对里的那个公钥加密的，而是用第三方密钥对里的那个用来欺诈小红的公钥加密的。这个时候小明就会迅速意识到自己遭遇了公钥欺诈。可以去找第三方秋后算账了。
如果只是秋后算账那肯定还不行。高级的非对称加密使用者，会在传送公钥时一并附上“指纹”，“指纹”是对每个公钥的一个唯一的标识符，原理和哈希差不多。小明和小红可以核对双方手上的那个公钥文件的指纹是否一致。只有一致的情况下才进行加密。
经过这种步骤，非对称加密可以说是无懈可击了。现在，从互联网上的TLS到自由软件中的GPG，家家都在使用非对称加密。它们将会创造一个更加安全和隐私的互联网。
而GnuPG则是GNU(GNU Not Unix)计划的一部分，是根据开放的OpenPGP标准编写的一个密码学程序，旨在实现人人易用的非对称加密
环境配置 要使用GPG的最基本功能：加密、解密和签名，那么环境配置是非常简单的。在类Unix操作系统中，由于系统库的很多功能组件都倚赖于GPG，它们往往已经预装了GPG程序。打开Terminal，输入gpg --version并检查返回的结果。
对于初级Linux用户，KDE社区提供了一个GPG的用户界面客户端——Kleopatra，它极大的简化了GPG的操作，非常适合用作教程。这个程序在Windows上也同样可用。请直接访问您Linux的应用商店安装Kleopatra.
GPG4Win是为Windows用户准备的一个完全GPG套件，其中包含了GPG的常用程序：GPG本体、Kleopatra和Gpg Privacy Assistant等等。
GPG4Win下载
图形化使用教程 创建第一个密钥对 本文以Kleopatra为例，介绍如何使用GPG的图形化界面。其他图形化界面的使用大同小异。
首先，初次打开软件，应该看到这个页面：
请点击“新建密钥对”按钮，以开始创建您的第一个密钥对。
要创建第一个密钥对，需要填写一些必要的信息。请在名字一栏填上您的名字（不必真实，但要可供辨认）以及电子邮件地址（作为公钥的一部分，它将被公开，所以确保拥有足够的防范垃圾邮件的措施）.完成后点击“OK”按钮开始密钥对生成。
我的电脑中有用于短时间内生成大量随机数的专用芯片，所以这个过程很快就结束了。然而，对于不具备相关芯片的电脑，生成时需要大量的随机数，请随机地移动您的鼠标。这是利用独立个体的不确定性来给电脑创造真正的“绝对随机数”。
现在您已经拥有了第一个GPG密钥对。注意：这个密钥对是存在有效期的，这可以提升安全性。这也意味着GPG是时间敏感的加密算法，请在使用GPG时确保您的计算机时间和NTP时间差距在1秒以下。
导入别人的公钥 为了给别人加密文件（还记得原理吗？不记得了往前翻），我们需要拿到他的公钥。由于我们在本地练习使用，所以请按照刚刚的教程再创建第二个密钥对供练习使用。唯一的区别是由于刚刚已经创建了第一个密钥对，您不能在Kleopatra中简单找到那个按钮，所以请按下Ctrl+N按键来新建又一个密钥对。
现在，我已经创建了第二个密钥对：WallumLee。接下来，我会用HelimLee密钥对加密一段文字和一个文件给WallumLee
加密一段文字 生活中最常见的加密需要是加密一段文字。请随便在一个编辑器中输入一段文字，并用光标选中它，按下Ctrl+C复制。
接着，打开您的状态栏，找到Kleopatra标志性的红帽小人图标，右键它并依次选择，“剪切板”“加密”。将弹出这样一个页面
请点击“添加收件人”。我们的收件人是刚刚创建的Wallum Lee，所以选择那个密钥对。
确认选择正确后点击“OK”。注意，在某些情况下，我们可能希望也为自己加密一份文件，这时可以按住Ctrl键并用鼠标选择多个证书。
点击“下一个”按钮。经过一段时间会显示这个页面。
点击“确定”按键，这时，您的剪贴板内容会被替换成这样的字符串：
-----BEGIN PGP MESSAGE-----hF4Dcln9O/BWQA0SAQdAFpBc7nkdiZbbQ2HT1owL/eacTyPCPJAZWXBvXpi34yQwMAZ+t5mIuj1IdenSblTKk4EoC+MlXtHzH7NyybVdBJekEqbCVe5G1KuOjXAtMHHU1FUBCQIQGkMhy3GqDrJjAb12khE8IgEVGtC55ySFpd18/yAnbFfO5/jx+hBLNN9+4lqX3nsQMME49Is17XuWHMEt/7skhy2/hkT2/q+xHNp3IgD+SyhU=zqxj-----END PGP MESSAGE----- 这就是被加密过后的信息了。为了验证，请把加密后的字符串选中并复制，再次打开任务栏，右键单击Kleopatra图标-剪切板-解密/校验。并黏贴，您将会发现剪贴板中的内容被替换为了已经解密的字符串。在我的例子中，这串字符是“我是堾荷甃”。
加密文件 加密一段文字只是GnuPG少数情况下的使用例，多数情况下它被用来加密文件。请打开Kleopatra,在菜单中点击“签名/加密”按钮，选择您要加密的文件并确认。您将会看到这个页面</description>
    </item>
    
    <item>
      <title>浅谈统计独立访客(UV或Unique Visitors)的策略</title>
      <link>/cs/%E6%B5%85%E8%B0%88%E7%BB%9F%E8%AE%A1%E7%8B%AC%E7%AB%8B%E8%AE%BF%E5%AE%A2uv%E6%88%96unique-visitors%E7%9A%84%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 29 Jan 2023 12:59:00 +0000</pubDate>
      
      <guid>/cs/%E6%B5%85%E8%B0%88%E7%BB%9F%E8%AE%A1%E7%8B%AC%E7%AB%8B%E8%AE%BF%E5%AE%A2uv%E6%88%96unique-visitors%E7%9A%84%E7%AD%96%E7%95%A5/</guid>
      <description>统计独立访客一直以来都是互联网统计服务提供商们纠结的问题。这一问题曾经非常容易解决，但随着互联网的发展，精准统计独立访客反而变得越来越难了。
最粗暴，最不准确的方法使用IP地址。是的。在最古早时代，所有连入互联网的设备都有一个独立的IPv4地址。那末，只需要把每一个用户的IP地址都存进一个数据库里，来一个存一个。如果发现是重复的IP就算作是同一个用户的多次访问。如果发现是不重复的那就是一个新的用户。
所以我们说这个问题“曾经”很容易解决。然而由于云服务的兴起，IPv4的宝贵资源大多被云服务厂商抢去或被运营商保留，分配给用户的IP地址越来越少。对此，只能使用NAT(内网地址转换)来保障更多的用户能接入互联网络。这样一来使用IP地址作为用户的标识符变得不切实际了。更进一步，即使有一部分家庭网络出于某些原因确实有一个公共网络IP，它的下属有可能是链接了许多台设备的一个家庭局域网——而根据家庭的大小，由这种统计方式带来的误差最少是1,2个人，最大则可能有10多个人不等。
最致命的是，现在的家庭宽带，即使有公网IP，也大部分是动态IP，这使得统计还要考虑IP的变化导致一个按照两个算。
然而，IP地址数量虽然不能作为衡量独立访客的标准，却可以作为一个很好的网站性能指标。譬如一个网站声称可以接受2w+ IP的访问，就彰显了该网站服务器资源的雄厚。这是因为一般一个IP地址所带来的请求量是有限的，然而IP地址数量的上升则一定会带来请求数量的激增。所以用访问者IP地址的数量来帮助衡量网站的请求数量级。
随着GeoIP数据库的完善，IP地址则带上了隐私的位置信息。如果采用明文记录，则可能带来信息泄漏的安全隐患。所以大部分的网站都应该拒绝明文记录访问者的IP地址。
歪门邪道且令人迷惑的方法那么既然通过TCP这一传输层协议来实现对于用户数量的统计是有偏差的，用物理层的一些唯一标识符，比如MAC地址，如何呢？
然而这种想法虽然看起来很合理：MAC地址一般来讲都是唯一的，一般来讲都不会轻易改变——甚至可以用作用户的唯一标识符。可是实际上确实完全的馊主意。
首先，同IP地址一样的缘由是，尽管很多人并不在意，MAC地址也是属于用户的隐私信息。如果明文存储这些信息，尽管利用它们的难度比利用IP地址干坏事的难度要大，也可能造成严重的后果。例如在商场连接了公共网络后，如果你的MAC地址泄漏，坏人就可以根据MAC地址反查到你的电脑品牌和外观——而这就意味着他们能够直接通过肉眼观察法找到你和你的设备。这还是最低技术含量的一种滥用MAC地址可能带来的后果。
其次，很多路由设备会对原先客户端的MAC地址做一些不可预测的事。应该说，MAC地址是不是一定会存在于数据包的报头之中本身就是一个玄乎其玄的问题。如果用蜂窝移动数据，MAC地址可能会被去除或根本不会被发送。
最后，就连用户自己也有权限随意更改他们的MAC地址。且这么做并不会影响到他们上网。而且这种做法还被鼓励为是一种保护隐私的策略。原因已经阐释过。
当然这些原因都是“不推荐用MAC地址”的原因。还有一个最主要的因素是，在大部分情况下，是“不能用MAC地址”。目前在Web编程中获取用户MAC地址的方法实则相当有限。在服务端PHP提供的获取MAC地址的方法并不是广泛有效的（在Windows上工作在Linux上则永远也不会），而浏览器则将这种MAC数据作为用户的重点保护对象，除了像Internet Explorer这种电子古董允许通过JavaScript和ActiveX控件实现获取MAC地址以外，其他浏览器基本上不提供这类接口。
不过还有一种例外。如果你的WEB服务有一个客户端，情况就大不相同了。可以在客户端上获取用户的MAC，然后和应用数据一并发送给服务端。但如果是用专用客户端来统计用户数据的方法，还有更多更好更全面的解决方案，也不一定需要使用这种具有隐私风险的解决方案了。
循规蹈矩的方法（被广泛采用）所以我们还是回归实际，看看大部分的统计服务厂商是怎么做的。
一般来讲，像Google Analytics这样的三方统计服务，直接给每一个访客生成一串专属于他们的UUID或者其他唯一标识符字符串，然后存储到他们浏览器的Cookie当中，这样如果他们反复访问站点，相同的Cookie被发送，经过数据库的比对，就可以确定是同一个访客。反之也就可以比较精确地统计独立访客了。
然而这种统计方式的效果并不稳定，数据很容易虚高。典型的例子是用户清除了他们的浏览器缓存，用一些浏览器提供的所谓“一键清理”功能。这种情况下Cookies会被清除，于是他们就会被重新计算为一个新的独立访客。还有就是一个用户有多台设备或者一台设备上安装了多个浏览器，或者直接设置了每次关闭浏览器都自动清除所有Cookie。这样一来数据非常容易就变得很高。
同时，数据还可能会骤然降低。在互联网上已经出现了很多宣传广告拦截器的内容。这类软件一旦安装在用户的计算机中，它们大抵不会被关闭或者暂停。这本来就对依靠广告维生的网站不太友好。然而对网站主更加糟糕的一点在于，大部分这样的广告拦截器拦截的不只是广告，还有第三方统计，譬如Google Analytics.它们已经维护了一份名单，对应了所有可能的追踪器url和cookie模式。一旦侦测到类似内容或行动就进行拦截，使得这些使用拦截器的用户在第三方统计面前就如同隐形人。
针对cookie的用户端政策所带来的数据失真，最好的解决方法可能只是提示用户关闭他们的拦截器。然而如果网站上本没有广告，只是通过统计目的要求用户关闭拦截器是无理取闹的。且使用Google Analytics这类不自由的第三方统计系统本身就是不正当的，它们不是自由软件。更好的方案应该是就着问题解决问题，不要贪恋第三方的数据统计解决方案。
三方Cookie变单方Cookie在Firefox，来自不同根域名的Cookie被判断为三方Cookie.譬如yep.example.com提供给www.helim.net的Cookie对Helim.net的用户来讲就是第三方cookie.但是yep.helim.net提供给blog.helim.net的cookie则被认为是本地的cookie.这种机制使得用户可以利用umami这样的简单搭建的统计平台，建设自己的自由开放的统计平台，且享受周全的数据展示。然而这种方式可能对SEO无利。
如果用户使用Adguard这种专业的防追踪软件，来自不同子域名的Cookie也可能会被判断为三方Cookie.正如上一个例子中的后一者所讲，这回连yep.helim.net的cookie也被判断为第三方了。再糟糕一点，这些专业防止追踪的软件甚至会检测url中的文件名，直接拦截umami.js这样的必要的脚本文件，造成统计用户变得完全不可能。
于是乎，一种完全基于单方的解决方案就有可能实施。对于一些视流量为生命的大站，这么做也完全合理。使用完全相同的域名，在CMS中实现一套或简单或复杂的统计系统。这样追踪拦截器将完全无法分析哪些网络请求是必要的，哪些则是用作统计用途的。
只不过这种做法也可能会带来隐私隐患，而且可能耗费很多的精力，还带来用户的唾弃，由于这种不摆在明面上的数据收集。
总结又免费又完全安全又完全准确的方案，目前是不存在的，除非你要求每一个访问网站的用户都登录一个账户并实名认证，然后根据账户操作来判断独立访客，否则100%精确的UV统计还不可能实现。
目前的大流是使用Cookie或类似技术，然而IP地址统计依然可以作为数据估测和防止滥用的重要手段。</description>
    </item>
    
    <item>
      <title>祝愿全世界所有劳动者五一劳动节快乐！/ Happy May Day to all workers!</title>
      <link>/cs/%E7%A5%9D%E6%84%BF%E5%85%A8%E4%B8%96%E7%95%8C%E6%89%80%E6%9C%89%E5%8A%B3%E5%8A%A8%E8%80%85%E4%BA%94%E4%B8%80%E5%8A%B3%E5%8A%A8%E8%8A%82%E5%BF%AB%E4%B9%90--happy-may-day-to-all-workers/</link>
      <pubDate>Sun, 01 May 2022 10:28:57 +0000</pubDate>
      
      <guid>/cs/%E7%A5%9D%E6%84%BF%E5%85%A8%E4%B8%96%E7%95%8C%E6%89%80%E6%9C%89%E5%8A%B3%E5%8A%A8%E8%80%85%E4%BA%94%E4%B8%80%E5%8A%B3%E5%8A%A8%E8%8A%82%E5%BF%AB%E4%B9%90--happy-may-day-to-all-workers/</guid>
      <description>劳动节是属于全体劳动者、全体无产阶级的节日，让我们在此庆祝五一劳动节，纪念美国工人的英勇罢工！
May Day is a day for all workers.Let us celebrate it together, and remember the brave behavior of American workers!</description>
    </item>
    
  </channel>
</rss>
